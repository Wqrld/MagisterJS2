'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

module.exports = function babelPluginDedent(babel) {
	var t = babel.types;

	return {
		visitor: {
			CallExpression: function CallExpression(path) {
				var node = path.node;

				if (t.isIdentifier(node.callee, { name: 'dedent' })) {
					if (t.isTemplateLiteral(node.arguments[0])) {
						transform(node.arguments[0].quasis);
						return path.replaceWith(node.arguments[0]);
					} else if (t.isTaggedTemplateExpression(node.arguments[0])) {
						transform(node.arguments[0].quasi.quasis);
						return path.replaceWith(node.arguments[0]);
					}
				}
			},
			TaggedTemplateExpression: function TaggedTemplateExpression(path) {
				var node = path.node;

				if (t.isIdentifier(node.tag, { name: 'dedent' })) {
					transform(node.quasi.quasis);
					return path.replaceWith(node.quasi);
				}
			}
		}
	};
};

function transform(quasis) {
	var elements = quasis.filter(function (element) {
		return element.type === 'TemplateElement';
	});
	var matches = [];

	rtrim(elements[elements.length - 1]);

	elements.forEach(function (element) {
		var match = undefined;

		if (match = element.value.raw.match(/\n[\t ]+/g)) {
			matches.push.apply(matches, _toConsumableArray(match));
		}
	});

	if (matches.length) {
		(function () {
			var _Math;

			var size = (_Math = Math).min.apply(_Math, _toConsumableArray(matches.map(function (value) {
				return value.length - 1;
			})));
			var pattern = new RegExp('\n[\t ]{' + size + '}', 'g');

			['raw', 'cooked'].forEach(function (type) {
				elements.forEach(function (element) {
					element.value[type] = element.value[type].replace(pattern, '\n');
				});
			});
		})();
	}

	ltrim(elements[0]);
}

function ltrim(element) {
	var pattern = /^\r?\n/;

	if (pattern.test(element.value.raw)) {
		element.value.raw = element.value.raw.replace(pattern, '');
		element.value.cooked = element.value.cooked.replace(pattern, '');
	}

	return element;
}

function rtrim(element) {
	var match = undefined;

	if (match = element.value.raw.match(/\r?\n([\t ]*)$/)) {
		var pattern = new RegExp('\r?\n[\t ]{' + match[1].length + '}$');

		element.value.raw = element.value.raw.replace(pattern, '');
		element.value.cooked = element.value.cooked.replace(pattern, '');
	}

	return element;
}